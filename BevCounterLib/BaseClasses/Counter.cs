//*************************************************************************************************
//
// Library for the control of various frequency counters via serial port or ethernet.
// Attention: currently a single board is supported (and tested) only
// 
// Author: Stefan Haas, 2015
//
// Usage:
// 1.) create instance of the respective counter class with port as parameter
// 2.) call one of the methods (see source)
//
// Example:
// 
//  
// 
// 
// version history
//
// 0.99 TimeOutEventHandler added 
// 0.97 _GetCounterValue() in HpSerial provided with try/catch.
//      Otherwise will crash on calling Disconnect() while still in StartMeasurementLoopThread()
// 0.96 added private variable stillInLoop to prevent generating new loop while a different one still active
// 0.94 first working version
// 
//*************************************************************************************************


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;

namespace Bev.Counter
{
    public abstract class Counter : Instrument
    {
        #region Variables
        protected CultureInfo intrumentCulture = new CultureInfo("en-US");
        protected bool connected;
        protected bool stillInLoop; // MM
        protected string portname;
        protected volatile bool stopRequest;
        protected List<Tuple<DateTime, double>> data;
        protected int loopSamples;
        protected DateTime initTime;  // MM
        protected DateTime sampleTime; // MM
        protected double? lastValue;
        protected Thread thread;
        protected MeasurementMode measurementMode;
        protected GateTime gateTime;
        protected double dGateTime;
        #endregion

        #region Properties
        /// <summary>
        /// <c>true</c> if connected, <c>false</c> otherwise.
        /// </summary>
        public bool IsConnected { get { return connected; } }

        /// <summary>
        /// The port where the counter is connected (e.g. "COM1")
        /// </summary>
        public string Portname { get { return portname; } }

        /// <summary>
        /// A list of time/value pairs generated by <c>StartMeasurementLoop()</c>.
        /// </summary>
        public List<Tuple<DateTime, double>> Data { get { return data; } }

        /// <summary>
        /// The last frequency value obtained from the counter.
        /// </summary>
        public double? LastValue { get { return lastValue; } }

        /// <summary>
        /// The time of the last frequency value obtained by from the counter.
        /// </summary>
        public DateTime SampleTime { get { return sampleTime; } }
        
        /// <summary>
        /// The time when the counter was initialized (= when the object was instantiated).
        /// </summary>
        public DateTime InitTime { get { return initTime; } }

        /// <summary>
        /// gets or sets the <c>MeasurementMode</c>.
        /// </summary>
        public MeasurementMode MeasurementMode { get { return measurementMode; } set { measurementMode = value; }}

        /// <summary>
        /// gets or sets the <c>GateTime</c> as a enum member.
        /// </summary>
        public GateTime GateTime { get { return gateTime; } set { gateTime = value; }}

        /// <summary>
        /// gets or sets the <c>DGateTime</c> as a double.
        /// </summary>
        public double DGateTime { get { return dGateTime; } set { dGateTime = value; }}
        #endregion

        #region Ctor
        /// <summary>
        /// A frequency counter is just an instrument.
        /// </summary>
        protected Counter():base("Frequency counter")
        {
            connected = false;
            stillInLoop = false;
            stopRequest = false;
            data = new List<Tuple<DateTime, double>>();
            loopSamples = 0;
            lastValue = null;
            initTime = DateTime.UtcNow;  // MM   
        }
        #endregion

        /// <summary>
        /// Abstract method. Expected to connect to the instrument.
        /// </summary>
        public abstract void Connect();

        /// <summary>
        /// Sets the given string to the portname and calls abstract method Connect().
        /// </summary>
        /// <param name="port">The portname given.</param>
        public virtual void Connect(string port)
        {
            portname = port;
            Connect();
        }

        /// <summary>
        /// Abstract method. Expected to disconnect the instrument.
        /// </summary>
        public abstract void Disconnect();

        /// <summary>
        /// Sets the measurement mode of the counter, particulary the mode and the gatetime
        /// and calls GateTimeToDouble().
        /// </summary>
        /// <param name="mm">Measurement mode to be set (frequency/totalize/unknown)</param>
        /// <param name="gt">Gatetime to be set (0.1s/1s/10s)</param>
        public virtual void SetupMeasurementMode(MeasurementMode mm, GateTime gt)
        {
            measurementMode = mm;
            gateTime = gt;
            GateTimeToDouble();
        }

        /// <summary>
        /// Converts the gatetime enumeration to double and saves the value in <c></c>dGateTime</c>.
        /// </summary>
        protected void GateTimeToDouble()
        {
            switch (gateTime)
            {
                case GateTime.Gate01s:
                    dGateTime = 0.1;
                    break;
                case GateTime.Gate1s:
                    dGateTime = 1;
                    break;
                case GateTime.Gate10s:
                    dGateTime = 10;
                    break;
                default:
                    dGateTime = 0;
                    break;
            }
        }

        /// <summary>
        /// Abstract method. Expected to send the given string to the instrument.
        /// </summary>
        /// <param name="cmd">string to be sent.</param>
        public abstract void SendCommand(string cmd);

        /// <summary>
        /// Abstract method. Expected to get the next line in the buffer of the counter.
        /// </summary>
        /// <returns>Next line in the buffer of the counter.</returns>
        public abstract string ReadLine();

        /// <summary>
        /// Abstract method. Expected to get the next value in the buffer of the counter.
        /// </summary>
        /// <returns>Next value from the counter. Null if something went wrong.</returns>
        protected abstract double? _GetCounterValue();

        /// <summary>
        /// Gets the next value in the buffer of the counter by calling <c>_GetCoutnerValue</c>.
        /// Sets the <c>smapleTime</c> to the time of calling this method and raises the <c>UpdatedEventHandler</c>.
        /// </summary>
        /// <returns>Next value from the counter or <c>null</c> if something went wrong.</returns>
        public virtual double? GetCounterValue()
        {
            lastValue = _GetCounterValue();
            sampleTime = DateTime.UtcNow;
            if (lastValue == null) TimeOutEventHandler(this, new EventArgs());
            UpdatedEventHandler(this, new EventArgs());
            return lastValue;
        }

        /// <summary>
        /// Starts a loop and saves the values from <c>GetCounterValue</c> in the list <c>data</c>
        /// Loop stops if <c>stopRequest</c> is set to true or if <c>loopSamples</c> is reached.
        /// At the end <c>ReadyEventHandler</c> is raised.
        /// </summary>
        protected virtual void StartMeasurementLoop()
        {
            if (stillInLoop) return;
            stillInLoop = true;
            int i = 0;
            Tuple<DateTime, double> dataPair;
            while (!stopRequest && i < loopSamples)
            {
                double? x = GetCounterValue();
                if (x != null)
                {
                    dataPair = new Tuple<DateTime, double>(sampleTime, (double)x);
                    data.Add(dataPair);
                    i++;
                }
            }
            stillInLoop = false;
            ReadyEventHandler(this, new EventArgs());
        }

        /// <summary>
        /// Sets <c>loopSamples</c> to the parameter given,clears all data in memory and calls <c>StartMeasurementLoop</c> in a thread.
        /// </summary>
        /// <param name="n">Number of samplesto make.</param>
        public virtual void StartMeasurementLoopThread(int n)
        {
            if (stillInLoop) return;
            loopSamples = n;
            stopRequest = false;
            data.Clear();
            thread = new Thread(new ThreadStart(StartMeasurementLoop));
            thread.Start();
        }

        /// <summary>
        /// Like <c>StartMeasurementLoopThread</c> but makes 2^31 samples.
        /// </summary>
        public virtual void StartMeasurementLoopThread()
        {
            StartMeasurementLoopThread(Int32.MaxValue);
        }

        /// <summary>
        /// Sets <c>stopRequest</c> to true.
        /// </summary>
        public void RequestStopMeasurementLoop()
        {
            stopRequest = true;
        }


        #region event declarations

        public delegate void CounterEventHandler(object obj, EventArgs e);

        public event CounterEventHandler UpdatedEventHandler;

        public event CounterEventHandler ReadyEventHandler;

        public event CounterEventHandler TimeOutEventHandler;

        #endregion
    }
}
